/**
 * @file SerialLineIP.hpp
 * @author BigeYoung (SCUT.BigeYoung@gmail.com)
 * @brief SerialLineIP 是一种简单的数据链路层串口协议，
 *  提供了封装成帧和透明传输的功能。
 * @warning STANDARD C++03 REQUIRED! 需要C++03以上标准支持！
 *  - C++03起，vector 元素相继存储，因此，您能用指向元素的常规指针
 *  访问元素。例如，对于返回值data，您可以使用&data[0]获取数组首地址。
 *  [C++标准:vector](https://zh.cppreference.com/w/cpp/container/vector)
 *  - 依照 ISO C++ 标准建议，本程序的函数直接返回 vector 容器。
 *  在支持具名返回值优化(NRVO)的编译器上可获得最佳性能。
 *  [C++标准:复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)
 * @see [RFC-1055: SLIP 协议文档](https://tools.ietf.org/html/rfc1055)
 * @version 0.1
 * @date 2018-12-24
 * 
 * @copyright Copyright 华工机器人实验室(c) 2018
 * 
 */
#include <stdio.h>
#include <stdint.h> /* uint8_t */
#include <assert.h> /* assert */
#include <vector>   /* vector */
#include "SerialLineIP.hpp"
using namespace SerialLineIP;

/**
 * @brief Serial Line IP PACK
 * @param p_PDU 起始位置指针
 * @param PDU_len PDU 字节长度
 * @return std::vector<uint8_t> SDU
 * @note Service Data Unit (SDU) 指本层封包后产生的数据单元
 *       Protocol Data Unit (PDU) 指上层协议数据单元
 */
std::vector<uint8_t> SerialLineIP::Pack(const void *const p_PDU, int PDU_len)
{
    uint8_t *p_PDU_data = (uint8_t *)p_PDU;
    /* 计算所需内存空间
     */
    int SDU_len = PDU_len + 2; //添加首尾2个END
    for (uint8_t *p = p_PDU_data; p < p_PDU_data + PDU_len; p++)
    {
        if ((*p == END) || (*p == ESC))
        {
            SDU_len++;
        }
    }

    std::vector<uint8_t> SDU_data;
    SDU_data.reserve(SDU_len);

    /* send an initial END character to flush out any data that may
     * have accumulated in the receiver due to line noise
     */
    SDU_data.push_back(END);

    for (uint8_t *p = p_PDU_data; p < p_PDU_data + PDU_len; p++)
    {
        switch (*p)
        {
        /* if it's the same code as an END character, we send a
         * special two character code so as not to make the
         * receiver think we sent an END
         */
        case END:
            SDU_data.push_back(ESC);
            SDU_data.push_back(ESC_END);
            break;

        /* if it's the same code as an ESC character,
         * we send a special two character code so as not
         * to make the receiver think we sent an ESC
         */
        case ESC:
            SDU_data.push_back(ESC);
            SDU_data.push_back(ESC_ESC);
            break;

        /* otherwise, we just send the character
         */
        default:
            SDU_data.push_back(*p);
        }
    }

    /* tell the receiver that we're done sending the packet
     */
    SDU_data.push_back(END);

    /* 确认计算所需内存空间与实际内存空间一致
     */
    assert(SDU_data.size() == SDU_len);

    return SDU_data;
}

/**
 * @brief Serial Line IP UNPACK
 * @param p_SDU 起始位置指针
 * @param SDU_len SDU 字节长度
 * @return std::vector<uint8_t> PDU
 * @note Service Data Unit (SDU) 指本层解包前的数据单元
 *       Protocol Data Unit (PDU) 指上层协议数据单元
 */
std::vector<uint8_t> SerialLineIP::Unpack(const void *const p_SDU, int SDU_len)
{
    std::vector<uint8_t> PDU_data;
    PDU_data.reserve(SDU_len - 2); //分配足够多的内存空间，减去首位两个END
    bool begin = false;

    uint8_t *p_SDU_data = (uint8_t *)p_SDU;
    for (uint8_t *p = p_SDU_data; p < p_SDU_data + SDU_len; p++)
    {
        /* skip until first END character found
         */
        if (!begin)
        {
            if (*p != END)
                continue;
            else
                begin = true;
        }

        /* handle bytestuffing if necessary
         */
        switch (*p)
        {
        /* if it's an END character then we're done with
         * the packet
         */
        case END:
            /* a minor optimization: if there is no
             * data in the packet, ignore it. This is
             * meant to avoid bothering IP with all
             * the empty packets generated by the
             * duplicate END characters which are in
             * turn sent to try to detect line noise.
             */
            if (PDU_data.size() > 0)
                return PDU_data;
            else
                break;

        /* if it's the same code as an ESC character, wait
         * and get another character and then figure out
         * what to store in the packet based on that.
         */
        case ESC:
            p++;

            /* if "p" is not one of these two, then we
             * have a protocol violation.  The best bet
             * seems to be to leave the byte alone and
             * just stuff it into the packet
             */
            switch (*p)
            {
            case ESC_END:
                PDU_data.push_back(END);
                break;
            case ESC_ESC:
                PDU_data.push_back(ESC);
                break;
            default:
            /* ESC 后面跟了其他字符 
             * 这在协议中没有定义，
             * 则认为这一帧出现差错。
             */
                begin = false;
                PDU_data.clear();
            }
            break;

        /* here we fall into the default handler and let
         * it store the character for us
         */
        default:
            PDU_data.push_back(*p);
        }
    }
    /* 如果没有结束'END'标识符，则返回空
     */
    PDU_data.clear();
    return PDU_data;
}