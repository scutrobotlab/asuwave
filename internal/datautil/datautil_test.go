package datautil

// import (
// 	"encoding/json"
// 	"testing"

// 	"github.com/scutrobotlab/asuwave/internal/variable"
// )

// func TestMakeCmd(t *testing.T) {
// 	cases := []struct {
// 		act  uint8
// 		v    variable.T
// 		want []byte
// 	}{
// 		{
// 			ActModeWrite,
// 			variable.T{
// 				Board: 1,
// 				Name:  "a",
// 				Type:  "float",
// 				Addr:  0x20123456,
// 				Data:  -8.25,
// 				Tick:  0,
// 			},
// 			[]byte{0x1, 0x7, 0x4, 0x56, 0x34, 0x12, 0x20, 0x0, 0x0, 0x4, 0xc1, 0x0, 0x0, 0x0, 0x0, 0xa},
// 		},
// 	}

// 	for _, c := range cases {
// 		got := MakeCmd(c.act, &c.v)
// 		if string(got) != string(c.want) {
// 			t.Errorf("makeCmd(%#v,%#v) == %#v, want %#v", c.act, c.v, got, c.want)
// 		}
// 	}
// }

// func TestFindValidPart(t *testing.T) {
// 	cases := []struct {
// 		data     []byte
// 		startIdx int
// 		endIdx   int
// 	}{
// 		{
// 			data: []byte{
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x01, 0x02, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 			},
// 			startIdx: 0,
// 			endIdx:   0,
// 		},

// 		{
// 			data: []byte{
// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 				0x0a,
// 			},
// 			startIdx: 0,
// 			endIdx:   20,
// 		},

// 		{
// 			data: []byte{
// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 				0x0a,
// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 				0x0a,
// 			},
// 			startIdx: 0,
// 			endIdx:   40,
// 		},

// 		{
// 			data: []byte{
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 				0x0a,

// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 				0x0a,

// 				0x01, 0x02, 0x04,
// 			},
// 			startIdx: 17,
// 			endIdx:   37,
// 		},

// 		{
// 			data: []byte{
// 				0x00, 0x00, 0x01, 0x02,
// 				0x0a,

// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x00, 0x00, 0x00, 0x01,
// 				0x0a,

// 				0x00, 0x0a, 0x01, 0x02,
// 			},
// 			startIdx: 5,
// 			endIdx:   25,
// 		},
// 		{
// 			data: []byte{
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0x30, 0x4, 0x0, 0x20,
// 				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 				0x41, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0xa8, 0x4, 0x0, 0x20,
// 				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 				0x41, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0xac, 0x1, 0x0, 0x20,
// 				0x0, 0x0, 0xb4, 0xbe, 0x0, 0x0, 0x0, 0x0,
// 				0x4b, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0x40, 0x3, 0x0, 0x20,
// 				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 				0x4b, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0xb8, 0x3, 0x0, 0x20,
// 				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 				0x4b, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0x30, 0x4, 0x0, 0x20,
// 				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 				0x4b, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0xa8, 0x4, 0x0, 0x20,
// 				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
// 				0x4b, 0xe2, 0x0, 0x0,
// 				0xa,

// 				0x1, 0x2, 0x4,
// 				0xac, 0x1, 0x0, 0x20, 0x0, 0x80, 0x9d, 0xbe,
// 				0x0, 0x0, 0x0, 0x0,
// 				0x55, 0xe2, 0x0, 0x0,
// 			},
// 			startIdx: 1,
// 			endIdx:   141,
// 		},
// 	}
// 	for _, c := range cases {
// 		s, n := FindValidPart(c.data)
// 		if s != c.startIdx || n != c.endIdx {
// 			t.Errorf("VerifyBuff(%#v) == %#v,%#v want %#v,%#v", c.data, s, n, c.startIdx, c.endIdx)
// 		}
// 	}
// }

// func TestMakeChartPack(t *testing.T) {
// 	cases := []struct {
// 		in        []byte
// 		listV     variable.ListT
// 		wantChart variable.ListChartT
// 		wantAdd   variable.ListT
// 		wantDel   variable.ListT
// 	}{
// 		{
// 			in: []byte{
// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x01, 0x00, 0x00, 0x00,
// 				0x0a,
// 			},
// 			listV: variable.ListT{
// 				0x80123456: {
// 					Board:      1,
// 					Name:       "a",
// 					Type:       "float",
// 					Addr:       0x80123456,
// 					SignalGain: 1,
// 				},
// 				0x80654321: {
// 					Board:      1,
// 					Name:       "b",
// 					Type:       "int",
// 					Addr:       0x80654321,
// 					SignalGain: 1,
// 				},
// 			},
// 			wantChart: variable.ListChartT{
// 				{
// 					Board: 1,
// 					Name:  "a",
// 					Data:  -8.25,
// 					Tick:  1,
// 				},
// 			},
// 			wantAdd: variable.ListT{
// 				0x80654321: {
// 					Board: 1,
// 					Name:  "b",
// 					Type:  "int",
// 					Addr:  0x80654321,
// 				},
// 			},
// 			wantDel: variable.ListT{},
// 		},

// 		{
// 			in: []byte{
// 				0x01, 0x02, 0x04,
// 				0x56, 0x34, 0x12, 0x80,
// 				0x00, 0x00, 0x04, 0xc1, 0x00, 0x00, 0x00, 0x00,
// 				0x01, 0x00, 0x00, 0x00,
// 				0x0a,
// 				0x01, 0x02, 0x04,
// 				0x21, 0x43, 0x65, 0x80,
// 				0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 				0x01, 0x00, 0x00, 0x00,
// 				0x0a,
// 			},
// 			listV: variable.ListT{
// 				0x80123456: {
// 					Board:      1,
// 					Name:       "a",
// 					Type:       "float",
// 					Addr:       0x80123456,
// 					SignalGain: 1,
// 				},
// 			},
// 			wantChart: variable.ListChartT{
// 				{
// 					Board: 1,
// 					Name:  "a",
// 					Data:  -8.25,
// 					Tick:  1,
// 				},
// 			},
// 			wantAdd: variable.ListT{},
// 			wantDel: variable.ListT{
// 				0x80654321: {
// 					Board: 1,
// 					Type:  "uint32_t",
// 					Addr:  0x80654321,
// 				},
// 			},
// 		},
// 	}
// 	isSameChart := func(a variable.ListChartT, b variable.ListChartT) (bool, string) {
// 		ja, _ := json.Marshal(a)
// 		jb, _ := json.Marshal(b)
// 		sa := string(ja)
// 		sb := string(jb)
// 		return sa == sb, "Chart Not Same: " + sa + ", " + sb
// 	}
// 	isSame := func(a variable.ListT, b variable.ListT) (bool, string) {
// 		if len(a) != len(b) {
// 			return false, ""
// 		}
// 		for i := range a {
// 			if a[i].Board != b[i].Board {
// 				return false, ""
// 			}
// 			if a[i].Addr != b[i].Addr {
// 				return false, ""
// 			}
// 			if variable.TypeLen[a[i].Type] != variable.TypeLen[b[i].Type] {
// 				return false, ""
// 			}
// 		}

// 		ja, _ := json.Marshal(a)
// 		jb, _ := json.Marshal(b)
// 		sa := string(ja)
// 		sb := string(jb)
// 		return true, "List Not Same: " + sa + ", " + sb
// 	}
// 	for _, c := range cases {
// 		gotChart, gotAdd, gotDel := MakeChartPack(&c.listV, c.in)
// 		if ok, msg := isSameChart(gotChart, c.wantChart); !ok {
// 			t.Errorf("MakeChartPack, chart: " + msg)
// 		}
// 		if ok, msg := isSame(gotAdd, c.wantAdd); !ok {
// 			t.Errorf("MakeChartPack, chart: " + msg)
// 		}
// 		if ok, msg := isSame(gotDel, c.wantDel); !ok {
// 			t.Errorf("MakeChartPack, chart: " + msg)
// 		}
// 	}
// }
